\documentclass{scrartcl}

\usepackage[hidelinks]{hyperref}
\usepackage[none]{hyphenat}

\title{COMP110 - Research Journal}

\author{Student Number: 1607539}

\begin{document}

\maketitle


\section*{Research journal}

\subsection*{When does a physical system compute? \cite{horsman2014does}}

Whilst on the surface acknowledging abstract and physical systems as separate entities is a null statement, already implied by their very nature, it sets the groundwork for a system to model the nature of computation. This serves to broaden our view of what a computer can be. Even biological computers can be built from the ground up once appropriate `logic-gates' or the aptly named `bio-logic gates' have been identified \cite{fisher2007executable}. In fact, when thinking of a program in its simplest forms: AND, NAND, XOR etc. any system which can resemble these processes can be potentially 'programmed' to execute a computation. Nuclear spins \cite{bechmann2011boolean}, liquid crystal \cite{harding2004evolution}, and even DNA \cite{jonoska2006theoretica} can have their properties harnessed and manipulated to mimic the principles of `conventional' computers. When defining unconventional constraint based operations, a computation may be performed providing that there is an underlying physical model sufficiently well characterised \cite{stepney2014local}. Once we have a system that can be manipulated to solve a problem, that system can function as a computer, ``Computing is the automation of our abstractions. We operate by mechanizing our abstractions, abstraction layers and their relationships'' \cite{wing2008computational}. In respects to game development, it is a fascinating concept to one day be able to play a game on a genetically modified lump of slime and being able to install new components by growing them. I wonder how the controls would operate? A slime controller does not sound very appealing whereas the Hollywood visuals of biological interfaces are a stark and suddenly realistic vision of the future. Assuming custom programs could be 'grown' could they evolve? Would they be programmed with a version of a c type code? I suspect that the programs would become more literal and a step back to a visual style of programming like flowcharts could become the norm.

\subsection*{Experimental Investigations of the Utility of Detailed Flowcharts in Programming \cite{shneiderman1977experimental}}

There are greatly differing opinions of the effectiveness of flow charts, whilst some believe ``the person who cannot flowchart cannot anticipate a problem, analyse the problem, plan the solution, or solve the problem''  \cite{shneiderman1977experimental}, others criticise them as ``a curse,'' ``a space-hogging exercise in drafting'' and ``a most thoroughly oversold piece of program documentation'' \cite{shneiderman1977experimental}. In a controlled study, where two groups which had some knowledge of programming were asked to complete a programming task, one using flowcharts. Subjects who had flowcharts did not perform differently than those who did not have flowcharts \cite{shneiderman1977experimental} questioning the merit of using detailed flowcharts  \cite{basili1986experimentation}, although this has been criticised in its use of such intermediate students and therefore in need of replication using experienced programmers \cite{brooks1980studying}. What can be agreed upon is their usefulness in terms of a teaching tool \cite{boyles2014investigation}, the methodical and often Boolean aspects closely mirror that of programming computer code although there is a trade-off between teaching flowcharting instead of programming; whether the time be better spent providing more instruction in the language being taught  \cite{gill2004teaching}. The obvious solution is to teach flowcharting concurrently with teaching the programming language. The most obvious advantage of flowcharting well is in its use as a visual pseudo code. In the context of game development, it is not uncommon for developers to use their own version of a language or to use a specific unconventional engine. Many people who cannot program or read computer code can understand and follow even the most complicated flow chart with very little training. Giving instructions to complicated processes such as iterations within constraints needed to solve many complicated problems.

\subsection*{A Fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space \cite{gilbert1988fast}}

These complicated problems can be complex in the way that they deal with difficult to understand concepts, more than four-dimensional matrix multiplications are an example, or complex in the number of iterations needed to solve. Sometimes both. For example, the detection of collisions and contact gains between moving bodies has the potential to be a very expensive computation. This is because accurate geometric models of realistic physical objects can contain hundreds, thousands, or even tens of thousands of geometric primitives \cite{featherstone2014rigid}. Game physics rely on algorithms for rigid body, fluid, and cloth \cite{seiler2008larrabee} and collision detection has been considered a major bottle-neck in computer-simulated environments \cite{cohen1995collide}. Referring back to the Hollywood visions of the future (picture immersion tanks and full body haptic suits) the calculations continue to increase. Consider a haptic device modelling contact constraints, surface shading, friction and texture, remaining stable even as the limits of the rendererâ€™s capabilities are reached. The computation time is approximately O(log n) where n is the number of polygons, in contrast to the rendering time for a graphic display, where the entire world may be visible at one time, is inherently O(n) \cite{cohen1995collide}. Optimisation is the key to unlocking new technology and the Gilbert-Johnson-Keerthi method \cite{gilbert1988fast} and its derivations are used in exciting technologies relating to hand prose estimation \cite{krejov2015combining} and robotics, given that computational efficiency of evolutionary algorithms is better than those of the conventional and mathematical techniques available in literature \cite{saravanan2010evolutionary}. However, as complexity and a focus on computational efficiency increases, the readability often decreases. Even the most efficient code must be maintainable.

\subsection*{Go To Statement Considered Harmful \cite{dijkstra1968letters}}

Edsger W. Dijkstra said it best with ``The go to statement as it stands is just too primitive; it is too much an invitation to make a mess of one's program'' and perhaps worst with ``the observation that the quality of programmers is a decreasing function of the density of go to statements in the programs they produce'' \cite{dijkstra1968letters}. Although he did not just attack the go to instruction for reasons of taste or opinion, but supported his suggested ban by a carefully woven chain of reasoning. One may disagree with some of that argument, but not deny that the conclusion is backed by a well thought-out view of the software development process \cite{meyer1988object}. Maintaining a high level of rigor with not only the quality of the code but the practice of writing it is essential in writing clear, concise, and perhaps more importantly easily readable and maintainable programs. After all, ``Programming is not the same as coding, it entails the many diverse steps of software development. Software process programming should, likewise, not simply be coding, but seemed to entail the many non-coding steps usually associated with application development. Process modelling, testing, and evolution research seems to have borne that out'' \cite{osterweil1987software}. Not that Dijkstra did not hold some strong opinions, he is said to have once quipped that ``abstract data types are a remarkable theory, whose purpose is to describe stacks'', and that using the word ``bug'' is a lame attempt by software people to blame someone else by implying that mistakes somehow creep into the software from the outside while the developers are looking elsewhere - as if were not the developers who made the mistakes in the first place. 
Dijkstra advocated against the use of go to instructions largely to aid readability however I believe this decision should be left to the discretion of the programmer in regards to the program, ``without encouraging a programmer to create logical spaghetti'' \cite{knuth1974structured}. To an extent a well-structured program is a subjective concept. As McCracken has said, ``Few people would venture a definition. In fact, it is not clear that there exists a simple definition as yet'' \cite{mccracken1979revolution}. Indeed, ``certain go to statements which arise in connection with well-understood transformations are acceptable, provided that the program documentation explains what the transformation was'' \cite{knuth1974structured}. We understand complex things by systematically breaking them into successively simpler parts and understanding how these parts fit together locally. Thus, we have different levels of understanding, and each of these levels corresponds to an abstraction of the detail at the level it is composed from \cite{knuth1974structured}. I suppose that this abstraction in terms of readability relates directly to the capability of the reader. I would finish with some further quotes from Dijkstra:

\textbullet Write a paper promising salvation, make it a 'structured' something or a 'virtual' something, or 'abstract', 'distributed' or 'higher-order' or 'applicative' and you can almost be certain of having started a new cult.

\textbullet The art of programming is the art of organizing complexity, of mastering multitude and avoiding its bastard chaos as effectively as possible.

\textbullet If you want more effective programmers, you will discover that they should not waste their time debugging, they should not introduce the bugs to start with.

\textbullet Thank goodness we don't have only serious problems, but ridiculous ones as well.



\bibliographystyle{ieeetran}
\bibliography{references}

\end{document}


\cite{